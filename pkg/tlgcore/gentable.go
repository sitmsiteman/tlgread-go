//go:build ignore

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"sort"
	"strconv"
	"strings"
	"unicode"
)

const input = "UnicodeData.txt"
const output = "pkg/tlgcore/tables.go"

var betaToBase = map[rune]rune{
	'a': 'α', 'b': 'β', 'g': 'γ', 'd': 'δ', 'e': 'ε', 'z': 'ζ', 'h': 'η', 'q': 'θ',
	'i': 'ι', 'k': 'κ', 'l': 'λ', 'm': 'μ', 'n': 'ν', 'c': 'ξ', 'o': 'ο', 'p': 'π',
	'r': 'ρ', 's': 'σ', 'j': 'ς', 't': 'τ', 'u': 'υ', 'f': 'φ', 'x': 'χ', 'y': 'ψ', 'w': 'ω',
	'v': 'ϝ',
	':': '·', '?': ';', '\'': '’',
}

var uniToBetaDia = map[rune]string{
	'\u0313': ")", '\u0314': "(", '\u0301': "/", '\u0300': "\\",
	'\u0342': "=", '\u0308': "+", '\u0345': "|", '\u0304': "%", '\u0306': "&",
}

var betaDiaToUni = map[rune]string{
	')': "\u0313", '(': "\u0314", '/': "\u0301", '\\': "\u0300",
	'=': "\u0342", '+': "\u0308", '|': "\u0345", '%': "\u0304", '&': "\u0306",
}

func main() {
	fmt.Printf("Parsing %s...\n", input)
	decompMap := parseUnicodeData(input)

	var buf bytes.Buffer
	buf.WriteString("// Code generated by gentable.go; DO NOT EDIT.\n")
	buf.WriteString("package tlgcore\n\n")

	fmt.Println("Generating GreekBase...")
	buf.WriteString("var GreekBase = map[rune]rune{\n")
	var sortedBetaKeys []rune
	for b := range betaToBase {
		sortedBetaKeys = append(sortedBetaKeys, b)
	}
	sort.Slice(sortedBetaKeys, func(i, j int) bool { return sortedBetaKeys[i] < sortedBetaKeys[j] })

	for _, b := range sortedBetaKeys {
		g := betaToBase[b]
		buf.WriteString(fmt.Sprintf("\t%#x: %#x, // %c -> %c\n", b, g, b, g))
	}
	for _, b := range sortedBetaKeys {
		g := betaToBase[b]
		if !unicode.IsLetter(g) {
			continue
		}
		buf.WriteString(fmt.Sprintf("\t%#x: %#x,\n", unicode.ToUpper(b), unicode.ToUpper(g)))
	}
	buf.WriteString("}\n\n")

	fmt.Println("Generating Diacritics...")
	buf.WriteString("var Diacritics = map[rune]string{\n")
	for beta, uni := range betaDiaToUni {
		buf.WriteString(fmt.Sprintf("\t%#x: \"%s\",\n", beta, uni))
	}
	buf.WriteString("}\n\n")

	greekToBeta := make(map[rune]string)
	for b, g := range betaToBase {
		greekToBeta[g] = string(b)
	}

	type alphaEntry struct {
		r       rune
		betaStr string
	}
	var alphaEntries []alphaEntry

	type compEntry struct {
		key string
		val rune
	}
	var compEntries []compEntry

	seenCompKeys := make(map[string]bool)

	ranges := [][]rune{{0x0370, 0x03FF}, {0x1F00, 0x1FFF}}

	for _, rng := range ranges {
		for r := rng[0]; r <= rng[1]; r++ {
			if !unicode.IsPrint(r) {
				continue
			}
			atoms := dec(r, decompMap)
			if len(atoms) == 0 {
				continue
			}

			baseRune := atoms[0]
			isUpper := false
			if unicode.IsUpper(baseRune) {
				isUpper = true
				baseRune = unicode.ToLower(baseRune)
			}
			betaBaseStr, ok := greekToBeta[baseRune]
			if !ok {
				continue
			}

			var betaDias []string
			var uniDias []rune
			valid := true
			for i := 1; i < len(atoms); i++ {
				d := atoms[i]
				if bDia, ok := uniToBetaDia[d]; ok {
					betaDias = append(betaDias, bDia)
					uniDias = append(uniDias, d)
				} else {
					valid = false
					break
				}
			}
			if !valid {
				continue
			}

			sortBD(betaDias)
			sortUD(uniDias)

			var sbBeta strings.Builder
			if isUpper {
				sbBeta.WriteString("*")
			}
			sbBeta.WriteString(betaBaseStr)
			for _, d := range betaDias {
				sbBeta.WriteString(d)
			}

			var sbUni strings.Builder
			sbUni.WriteRune(atoms[0])
			for _, d := range uniDias {
				sbUni.WriteRune(d)
			}

			alphaEntries = append(alphaEntries, alphaEntry{r, sbBeta.String()})

			uniKey := sbUni.String()
			if !seenCompKeys[uniKey] {
				compEntries = append(compEntries, compEntry{uniKey, r})
				seenCompKeys[uniKey] = true
			}
		}
	}

	fmt.Println("Generating AlphaBase...")
	buf.WriteString("var AlphaBase = map[rune]string{\n")
	for _, e := range alphaEntries {
		buf.WriteString(fmt.Sprintf("\t%#x: %q,\n", e.r, e.betaStr))
	}
	buf.WriteString("}\n\n")

	fmt.Println("Generating UnicodeComposition...")
	buf.WriteString("var UnicodeComposition = map[string]rune{\n")
	for _, e := range compEntries {
		// Key is string, Value is Rune (Hex)
		buf.WriteString(fmt.Sprintf("\t%q: %#x,\n", e.key, e.val))
	}
	buf.WriteString("}\n")

	src, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Format error: %v", err)
	}
	if err := os.WriteFile(output, src, 0644); err != nil {
		log.Fatalf("Write error: %v", err)
	}
	fmt.Println("Done.")
}

func parseUnicodeData(path string) map[rune][]rune {
	f, err := os.Open(path)
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()
	m := make(map[rune][]rune)
	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		if line == "" {
			continue
		}
		parts := strings.Split(line, ";")
		if len(parts) < 6 {
			continue
		}
		r, _ := strconv.ParseInt(parts[0], 16, 32)
		decompStr := parts[5]
		if decompStr == "" || strings.Contains(decompStr, "<") {
			continue
		}
		var decomp []rune
		for _, h := range strings.Fields(decompStr) {
			val, _ := strconv.ParseInt(h, 16, 32)
			decomp = append(decomp, rune(val))
		}
		m[rune(r)] = decomp
	}
	return m
}

func dec(r rune, dm map[rune][]rune) []rune {
	if parts, ok := dm[r]; ok {
		var res []rune
		for _, p := range parts {
			res = append(res, dec(p, dm)...)
		}
		return res
	}
	return []rune{r}
}

func GetPriorDia(s string) int {
	switch s {
	case ")", "(", "\u0313", "\u0314":
		return 1
	case "+", "\u0308":
		return 2
	case "/", "\\", "=", "\u0301", "\u0300", "\u0342":
		return 3
	case "|", "\u0345":
		return 4
	default:
		return 99
	}
}

func sortBD(d []string) {
	sort.Slice(d, func(i, j int) bool { return GetPriorDia(d[i]) < GetPriorDia(d[j]) })
}

func sortUD(d []rune) {
	sort.Slice(d, func(i, j int) bool { return GetPriorDia(string(d[i])) < GetPriorDia(string(d[j])) })
}

